# %%
# Copyright (C) 2024 Analog Devices, Inc.
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#     - Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     - Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#     - Neither the name of Analog Devices, Inc. nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#     - The use of this software may or may not infringe the patent rights
#       of one or more patent holders.  This license does not release you
#       from the requirement that you obtain separate licenses from these
#       patent holders to use this software.
#     - Use of the software either in source or binary form, must be run
#       on or directly connected to an Analog Devices Inc. component.
#
# THIS SOFTWARE IS PROVIDED BY ANALOG DEVICES "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED.
#
# IN NO EVENT SHALL ANALOG DEVICES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, INTELLECTUAL PROPERTY
# RIGHTS, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
# THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

'''FMCW Range Processing Data from the Phaser (CN0566)
   Jon Kraft, April 22 2024'''
   
# Imports
import sys
import time
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
plt.close('all')

from target_detection_dbfs import cfar
config = np.load("radar_config.npy")          # these files are generated by the "Range_Doppler_Plot.py" program
all_data = np.load("phaserRadarData.npy")


# %%
""" Calculate and print summary of ramp parameters
"""
sample_rate = config[0]
signal_freq = config[1]
output_freq = config[2]
num_chirps = int(config[3])
chirp_BW = config[4]
ramp_time_s = config[5]
frame_length_ms = config[6]

PRI = frame_length_ms / 1e3
PRF = 1 / PRI

# Split into frames
N_frame = int(PRI * float(sample_rate))

# Obtain range-FFT x-axis
c = 3e8
wavelength = c / output_freq
slope = chirp_BW / ramp_time_s
freq = np.linspace(-sample_rate / 2, sample_rate / 2, N_frame)
dist = (freq - signal_freq) * c / (2 * slope)

# Resolutions
R_res = c / (2 * chirp_BW)
v_res = wavelength / (2 * num_chirps * PRI)

# Doppler spectrum limits
max_doppler_freq = PRF / 2
max_doppler_vel = max_doppler_freq * wavelength / 2

print("sample_rate = ", sample_rate/1e6, "MHz, ramp_time = ", int(ramp_time_s*(1e6)), "us, num_chirps = ", num_chirps)


# %%
# Function to process data
i = 0
cmn = ''
def get_radar_data():
    global i
    print(i)
    rx_bursts = []
    rx_bursts = all_data[i]
    i=int((i+1) % len(all_data))
    #rx_bursts_fft = np.fft.fft2(rx_bursts)
    rx_bursts_fft = np.fft.fft(rx_bursts)
    
    bias = 10
    num_guard_cells = 16
    num_ref_cells = 16
    cfar_method = 'average'
    use_CFAR = False
    if use_CFAR == True:
        for burst in range(num_chirps):
            threshold, targets = cfar(rx_bursts_fft[burst], num_guard_cells, num_ref_cells, bias, cfar_method)
            targets = targets.reshape(1,-1)  # make a row vector
            rx_bursts_fft[burst] = targets.filled(min(abs(rx_bursts_fft[burst])))  # fill the values below the threshold with -200 dBFS

    rx_bursts_fft = np.fft.fft(rx_bursts_fft.T).T   
    rx_bursts_fft = np.fft.fftshift(abs(rx_bursts_fft))
    range_doppler_data = np.log10(rx_bursts_fft).T
    radar_data = range_doppler_data
    num_good = len(radar_data[:,0])   
    
    center_delete = 6  # delete ground clutter velocity bins around 0 m/s
    if center_delete != 0:
        for g in range(center_delete):
            end_bin = int(num_chirps/2+center_delete/2)
            radar_data[:,(end_bin-center_delete+g)] = np.ones(num_good)*4.2
            
    range_delete = 50   # delete the zero range bins (these are Tx to Rx leakage)
    if range_delete != 0:
        for r in range(range_delete):
            start_bin = int(len(radar_data)/2)
            radar_data[start_bin+r, :] = np.ones(num_chirps)*4.2
    radar_data = np.clip(radar_data, 4, 5.5)  # clip the data to control the max spectrogram scale
    return radar_data

# %%
    
radar_data = get_radar_data()

range_doppler_fig, ax = plt.subplots(figsize=(14, 7))
extent = [-max_doppler_vel, max_doppler_vel, dist.min(), dist.max()]
cmaps = ['inferno', 'plasma']
cmn = cmaps[0]
try:
    range_doppler = ax.imshow(radar_data, aspect='auto',
        extent=extent, origin='lower', cmap=matplotlib.colormaps.get_cmap(cmn),
        )
except:
    print("Using an older version of MatPlotLIB")
    from matplotlib.cm import get_cmap
    range_doppler = ax.imshow(radar_data, aspect='auto', vmin=0, vmax=8,
        extent=extent, origin='lower', cmap=get_cmap(cmn),
        )
ax.set_title('Range Doppler Spectrum', fontsize=24)
ax.set_xlabel('Velocity [m/s]', fontsize=22)
ax.set_ylabel('Range [m]', fontsize=22)

max_range = 16
ax.set_xlim([-8, 8])
ax.set_ylim([0, max_range])
ax.set_yticks(np.arange(0, max_range, 2))
plt.xticks(fontsize=20)
plt.yticks(fontsize=20)

#print("sample_rate = ", sample_rate/1e6, "MHz, ramp_time = ", ramp_time, "us, num_chirps = ", num_chirps)
print("CTRL + c to stop the loop")
try:
    while True:
        radar_data = get_radar_data()
        range_doppler.set_data(radar_data)
        plt.show(block=False)
        plt.pause(0.1)
except KeyboardInterrupt:  # press ctrl-c to stop the loop
    pass




